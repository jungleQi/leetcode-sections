从子集和问题到背包问题
https://blog.csdn.net/h843653844/article/details/97619570

一、子集问题：
1、问题定义:
有一个包含n个元素{e1, e2, …, en}的集合S，每个元素ei都有一个对应的权值wi。现在有一个界限W，
我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下达到最大，这个便是子集合问题（事实上还有其他类型的子集和问题)

2、解题思路：
for i = 1, 2, ..., n
    for w = 0, ..., W
        if w < wi
            O[i, w] = O[i-1, w]
        else
            O[i, w] = max(O[i-1, w], wi + O[i-1, w-wi])
    endFor
endFor
算法实际上是实现了一个填表的过程，填了一张n*W的二维表格。整个算法的时间复杂度为O(nW)，显而易见，当W的值变得很大的时候，这个算法的效率堪忧

3、拓展：
现在暂时抛开效率问题，我们发现，上面给出的算法只能算出最优解的值，但是并没有给出所选择的子集合。即农民用这个算法之后只知道他最多能卖多少小番茄，
但还是不知道要卖给哪些收购商。为了解决这个问题，我们只需要反向搜索一下数组O即可在O(n)的时间内找出最优解的元素组合情况。
反向搜索的时候，如果O(i, w)等于O(i-1, w)，说明i没有被选择，继续对前面i-1个元素考虑重量为w时候的情况。
如果O(i, w)不等于O(i-1, w)的话，说明选择了i，然后接着就应该继续对前面i-1个元素考虑重量为(w-wi)时候的情况

二、背包问题：
1.问题定义：
把上面的子集和问题拓展一下，就变成了我们常见的背包问题了。问题定义：有一个包含n个元素{e1, e2, …, en}的集合S，
每个元素ei都有一个对应的权值wi和一个对应的价值vi。现在有一个界限W，我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下，
所有元素的价值总和达到最大。继续拿上面的农民买小番茄的例子来讲，假设现在每个收购商的出价都有所不同，收购商i打算收购wi万斤小番茄，出价vi。
农民只有W万斤能够提供给收购商，他希望合理选择收购商，使得卖小番茄的收益达到最大

2.解题思路：
if w < wi, O(i, w) = O(i-1, w)
else O(i, w) = max(O(i-1, w), vi + O(i-1, w-wi))

3.技巧：
3.1 一般都需要padding一个临界值 dp = [1] + [0]*N，即dp[0] = 1,  或者dp[0][0] = 1

3.2 在一组候选元素中，递增背包容量时，形成的状态转移方程，很容易导致一个元素被重复选择的错误。
为了避免这种错误，有两种方法：
1.dp的维度，由[元素个数][背包容量]形成2d数组，在每个维度上递增，形成状态转移方程
2.dp的维度，由[背包容量]形成1d数组，在该维度上，递增，形成状态转移方程。但是，递推循环的方式有讲究：
    ### 如果一个元素只能选择 一次 ###
    #遍历元素放在第一层
    for num in nums:
        #递推顺序是降序： 最大容量 -> 0
        for i in range(packageVolumn, 0, -1):
            #....
            dp[i] = max(dp[i], dp[i-num])
            #....

    ### 如果一个元素可以选择 多次 ###
    for coin in coins:
        #一个coin可以选择多次，所以下面采用coin -> amount+1的升序遍历
        #如果一个coin只能选择一次，就需要采用amount+1 ->coin的降序
        for i in range(coin, amount + 1):
            dp[i] += dp[i-coin]

3.坑：在3 level loop 里面，不能将2D -> 1D