递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间

1.暴力递归
画出递归树，发现重叠子问题
子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)
算法的时间复杂度为 O(2^n)，指数级别

2.带备忘录的递归
带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数
本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。
带备忘录的递归解法的效率已经和动态规划一样了。
实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，
向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，
直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。


3. 一种模型/三个特点/四个步骤：
3.1 阶段的划分：
    前提条件：
        假设存在序列arr[0...i]
    处理情形：
        3.1.1 每个数字arr[i]，0->i 就是一个处理阶段
        3.1.2 对于问题 740. Delete and Earn.py，需要利用Counter来得到每个数字的个数，counter.keys()就是新的处理序列，
              处理到每个key，就是一个处理阶段
        3.1.3 表面上给定的是days包含的几个阶段，但便于推理，将实际处理的阶段扩展成 [1 ... 366]

3.2 状态的选择：
    3.2.1 每个单元，参与或者不参与处理，这是每个单元的一种处理状态
    3.2.2

    dp[i]，i有时候是元素索引值，有时候i可能是元素值本身

3.3 状态的转移：
    3.3.1 状态转移的条件：设定的限制条件，可能只是限制了当前dp[i]，向低位推演的条件范围，不影响一般性质的阶段划分和状态转移
          (书架宽度被设定，求总体高度最低)

4.处理技巧：
4.1 dp[max(0,i-7)]+costs[1] 索引值的设定采用max(0,i-7)，避免越过边界. 如果用if else就没这么优雅
    dp[i-1][max(0,j-1):min(j+2,N)] 非常优雅的处理了边缘索引取值问题，不需要那么多if分支


