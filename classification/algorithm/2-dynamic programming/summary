递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间

1.暴力递归
画出递归树，发现重叠子问题
子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)
算法的时间复杂度为 O(2^n)，指数级别

2.带备忘录的递归
带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数
本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。
带备忘录的递归解法的效率已经和动态规划一样了。
实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」


啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，
向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，
直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

3.动态规划
引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式
千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table

「最优子结构」性质：原问题的解由子问题的最优解构成。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来
记住，要符合「最优子结构」，子问题间必须互相独立

4.阶段的划分：
对于序列arr[0...i] ,一般情况下直接划分i为每个阶段。但是对于问题 740. Delete and Earn.py，需要利用Counter来得到每个数字的
个数，对数字排序后，依次选择数字为每个阶段

5.关于状态的选择：
dp[i]，i有时候是元素索引值，有时候i可能是元素值本身