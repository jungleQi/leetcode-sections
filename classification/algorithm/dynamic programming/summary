递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间

1.暴力递归
画出递归树，发现重叠子问题
子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)
算法的时间复杂度为 O(2^n)，指数级别

2.带备忘录的递归
带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数
本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。
带备忘录的递归解法的效率已经和动态规划一样了。
实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」


啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，
向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，
直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。


3.动态规划
引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式
千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table

「最优子结构」性质：原问题的解由子问题的最优解构成。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来
记住，要符合「最优子结构」，子问题间必须互相独立

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的
如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。
因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏



一个模型三个特征：

它指的是动态规划适合解决的问题的模型。我把这个模型定义为“多阶段决策最优解模型”
我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。
每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值

现在，我们再来看，什么是“三个特征”？它们分别是最优子结构、无后效性和重复子问题
1. 最优子结构最优子结构指的是，问题的最优解包含子问题的最优解。
反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。
如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，
那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

2. 无后效性无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，
我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

3. 重复子问题这个概念比较好理解。
如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。
