1.padd a dummy head node, make many case more easily to process
2.using recursive to solve the problem on the back way

题型一：
#如果是从尾部开始修改链表，多半是在 "归" 的路上处理节点
#递归返回节点对象
    # 如果返回值为None，说明目前已经得到结果，可用于中断归中后续判断
    # 如果返回值非None，这是归中下一个需要用于处理的目标节点
# 注意临界条件时的拦截返回
# 注意节点调整时，不要形成环

题型二：
#list sort 或者merge的问题，转换成arr，然后排序，是一种简洁的方法
#保持next不变，只改变每个Node的val，按照sort顺序依次赋值

题型三：
#GOOD: 在单链表上操作，得到>=2个区域并且相连形成一个新的链表，最便捷清晰的思路是有几个区域就有几个头指针，形成几个
    子链表，遍历原始单链表时，将结点附加到合适的子链表，最后将子链表连成一个整体
#BAD: 如果直接在原始单链表上操作，会发现在一些corner case的干预下，主干处理逻辑流程会变得失控

题型四：
#对链表做删除:
    1.首先确定anchor(被删除节点的前序节点，用于连接被删除区域之后的剩余区域)
    2.然后确定被删除区域之后，被anchor串接的新节点