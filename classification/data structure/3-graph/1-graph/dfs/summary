一、图问题的要点和解决框架：
1、一般性的图遍历问题，就是dfs+backtracking算法在邻接表上的应用：
    1.1 构建graph结构： 当前节点:邻居多个节点 的关系 node:neighbors，如果每条边带有属性，则neighbors是一个小数组包含邻居节点及其属性
    1.2 确定遍历起始点(一个或者多个) 和 dfs的输入输出
    1.3 返回（显式或者隐式）： 如果已经完成既定目标就返回TRUE，如果dfs返回TRUE，就层层返回不做任何其他处理
    1.4 pruning：对于没有解的路径执行pruning
    1.5 防止死循环：visitor(数据结构可能是list，也可能是node:list)记录每条边(节点)的访问状态：
        set([node1, node2 ...])，visitor[node][False, True, ...], pathWeight[node] 或者 [WHITE, GRAY, BLACK]

上面这套dfs框架，不是什么有向graph问题都能够搞定，DFS有一定的局限性
--> 能解决哪些问题：
    1.从指定节点，寻找一条路径能覆盖所有的边
    2.哪些节点遍历的所有可能路径上是否有环
    3.从起始节点，是否能遍历完所有节点
    4.从起始节点，能否遍历到指定节点
    5.从指定节点，到达每个节点最小累计权值中的最大值 (node-weights pruning是关键)
    6.从哪个节点，所有遍历路径的权值总和不超过阈值，累积的节点总数最少 (node-weights pruning是关键，不然TLE)
--< 在框架下解决这些问题，可能需要额外应用一些技巧：WHITE-GRAY-BALCK、node-weights[i]

--> 不能解决哪些问题：
    1.所有节点之间的最小连接成本总和(边的权值是成本)
    2.递归子树随层数指数级增长，求遍历到每个节点的最少路径长度(会TLE，且比BFS慢很多)

2、特别适合BFS的图遍历问题：


1.图的问题，主要都是遍历问题(bfs+dfs)，而遍历过程的花样有很多
1.1 有向图衍生问题：
1.1.1 要求把所有路径都走到(是存在这样的路径的)，输出访问节点的排列顺序
      key-1 同一条有向边有几条，这时候就要记录每条边是否已经访问过
      key-2 成功返回条件是 当前累计节点个数 == 原始边数+1
1.1.2 每条边有耗时，从某个指定节点开始，是否能遍历到所有节点，并得出到达所有节点的时间
      (到达每个节点的最少累积权值minWeights，最后得到max(minWeights_node1, minWeights_node2, ... minWeights_nodeN))
      key-1 记录每个点的当前最小累积权值，如果遇到更小的累积权值路径，就更新
      key-2 防止路径被循环访问和pruning访问某个节点时更大权值的路径分支，可以直接利用key-1进行判断
1.1.3 哪些节点的遍历，后续不会出现环路。
      key-1 判断某个节点后续遍历是否有环，这个比较容易，但是要判断哪些节点后续遍历没有环路，一般方法很容易LTE，
            最好能对每个遍历过的节点留有判断，如果访问过就立即有判断并返回，没有访问过，就开始遍历判断


