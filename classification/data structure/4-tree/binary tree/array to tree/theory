一、数组(一对)转成二叉树 algorithm：
    recursion(arr1, arr2)
1. 在"递"的时候，就新建当前根节点root，通过两个数组，找出一个值 赋给根节点 root.val
2. 当前root的左右两个子树root.left/root.right，通过递归返回赋值。
   递归传入的子树的数组，是在依据root.val对两个数组分别分裂之后得到的子数组集合
3. 进入递归就判断数组如果为空，返回none，结束递归的"递"，开始"归"
4. 最后返回根节点
5.在递归中完成以上4步，因为二叉树是规律非常强的树，只需要对最简单的数组和子树做一次推演，就代表整棵树适用


二、二叉树和链表的递归处理方式，思想内核一致，不同在于：
1.链表只需要关注当前节点一条路径的递与归
2.二叉树，需要关注当前节点的左、右子树两条路径的递与归
    那么，是不是意味着二叉树问题比链表问题，更难以处理呢？
    其实不是，二叉树的规律性极强，对左子树和右子树的处理逻辑是相同（对称）的，考虑清楚对一个子树的处理，
基本上就确定了另一边子树的处理方式，所以一般并行递归处理左右子树。
    从这个层面来说，二叉树和链表的递归处理是一个类型的问题

三.intuition:  ？？？
可以先对求解的二叉树进行一次遍历，得到这个数组，从而理清数组的形成规律，一般规律有一下几个：
其中比较重要的是得到根节点值，和左右子树对应的子数组
A. 一个数组是BST遍历而来，这个数组是升序的，那么len(nums)/2就是根节点
   (如果数组个数是偶数，中间有两个数都可能是根节点，选择一个就可以建树) ???
B. nums是先序或者后序遍历而来，那么根节点分别对应数组的第一个或者最后一个，
   左子树和右子树就要从中序遍历中根据当前根节点的值，将其一分为二。???
