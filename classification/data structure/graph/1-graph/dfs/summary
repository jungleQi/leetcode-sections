1.图的问题，主要都是遍历问题(bfs+dfs)，而遍历过程的花样有很多

1.1 有向图衍生问题：
1.1.1 要求把所有路径都走到(是存在这样的路径的)，输出访问节点的排列顺序
      key-1 同一条有向边有几条，这时候就要记录每条边是否已经访问过
      key-2 成功返回条件是 当前累计节点个数 == 原始边数+1
1.1.2 每条边有耗时，从某个指定节点开始，是否能遍历到所有节点，并得出到达所有节点的时间
      (到达每个节点的最少累积权值minWeights，最后得到max(minWeights_node1, minWeights_node2, ... minWeights_nodeN))
      key-1 记录每个点的当前最小累积权值，如果遇到更小的累积权值路径，就更新
      key-2 防止路径被循环访问和pruning访问某个节点时更大权值的路径分支，可以直接利用key-1进行判断
1.1.3 哪些节点的遍历，后续不会出现环路。
      key-1 判断某个节点后续遍历是否有环，这个比较容易，但是要判断哪些节点后续遍历没有环路，一般方法很容易LTE，
            最好能对每个遍历过的节点留有判断，如果访问过就立即有判断并返回，没有访问过，就开始遍历判断

2.只是图的遍历，不同于数的遍历，图的特点主要有：
2.1 图为了防止死循环递归，需要记录访问过节点的备忘数据，从而判断某个节点是否已经访问过，有多种方式：
    set([node1, node2 ...])，visitor[node][False, True, ...], pathWeight[node]
2.2 判断访问完graph所有的边或者节点



有向图dfs本质特点：
1.为了防止死循环：
    如果对访问的节点进行记录，不会对环的最后一条边进行访问判定；
2.由于同一节点有不同子递归树，可能会对不同自递归树的共有边或者节点进行多次访问

dfs框架：(这个框架只能保证都能遍历得到，不能保证遍历得好)
1.对数据集和只需要做 是与否 的判断：
    如果找到想要的结果就马上撤，一般返回True，递归返回判断是True，就层层返回；
    如果在某个节点建立子树时进行pruning，一般是conitue；
    如果没有找到，前面一直没有机会返回True，就在最后返回False

上面这套dfs框架，不是什么有向graph问题都能够搞定，DFS有一定的局限性
--> 能解决哪些问题：
    1.从指定节点，寻找一条路径能覆盖所有的边
    2.得到每个节点最小累计权值(可能有多条路径到达一个节点)
    3.每个节点遍历的所有可能路径上是否有环
    4.从起始节点，是否能遍历完所有节点
    5.从起始节点，能否遍历到指定节点
--< 在框架下解决这些问题，可能需要额外应用一些技巧：WHITE-GRAY-BALCK、node-weights[i]、

--> 不能解决哪些问题：
    1.所有节点之间的最小连接成本总和(边的权值是成本)


一般性的图遍历问题，就是dfs+backtracking算法在邻接表上的应用：
A.何时返回（显式或者隐式）
B.pruning
C.防止死循环
D.节点的状态：[False，True]-避免死循环，[WHITE, GRAY, BLACK]-避免死循环+哪些导致或者不会导致死循环








题型要求：
所有边都要遍历到

所有节点都要遍历到