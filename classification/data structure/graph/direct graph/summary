1.图的问题，主要都是遍历问题(bfs+dfs)，而遍历过程的花样有很多

1.1 有向图衍生问题：
1.1.1 要求把所有路径都走到(是存在这样的路径的)，输出访问节点的排列顺序
      key-1 同一条有向边有几条，这时候就要记录每条边是否已经访问过
      key-2 成功返回条件是 当前累计节点个数 == 原始边数+1
1.1.2 每条边有耗时，从某个指定节点开始，是否能遍历到所有节点，并得出到达所有节点的时间
      (到达每个节点的最少累积权值minWeights，最后得到max(minWeights_node1, minWeights_node2, ... minWeights_nodeN))
      key-1 记录每个点的当前最小累积权值，如果遇到更小的累积权值路径，就更新
      key-2 防止路径被循环访问和pruning访问某个节点时更大权值的路径分支，可以直接利用key-1进行判断

2.只是图的遍历，不同于数的遍历，图的特点主要有：
2.1 图为了防止死循环递归，需要记录访问过节点的备忘数据，从而判断某个节点是否已经访问过，有多种方式：
    set([node1, node2 ...])，visitor[node][False, True, ...], pathWeight[node]
2.2 判断访问完graph所有的边或者节点

图问题，就是dfs+backtracking算法在邻接表上的应用，主要注意三个问题：
A.何时返回（显式或者隐式）
B.pruning
C.防止死循环