1.完成递归或者回溯：
    如果有并行的，需要for循环，多次自我调用
    如果是串行的，只需要变化传入参数的情况下，单层自我调用
    如果既有并行又有串行，就if else 分支判断，对并行的部分用for循环，多次自我调用；对串行的部分，变化入参，单次调用


code pattern:
    def backtrack(candidate):
        if find_solution(candidate):
            output(candidate)
            return

        # iterate all possible candidates.
        for next_candidate in list_of_candidates:
            if is_valid(next_candidate):
                # try this partial candidate solution
                place(next_candidate)
                # given the candidate, explore further.
                backtrack(next_candidate)
                # backtrack
                remove(next_candidate)

1.Unlike brute-force search, in backtracking algorithms we are often able to determine if a partial solution
candidate is worth exploring further (i.e. is_valid(next_candidate)), which allows us to prune the search zones

2.There are two symmetric functions that allow us to mark the decision (place(candidate))
and revert the decision (remove(candidate)).
