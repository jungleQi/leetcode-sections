一、定义：
    对于任何有向图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向图而言可能存在多个这样的结点排序）。
该排序满足这样的条件——对于图中的任意两个结点u和v，若存在一条有向边从u指向v，则在拓扑排序中u一定出现在v前面。
    举例来说，如果我们将一系列需要运行的任务构成一个有向图，图中的有向边则代表某一任务必须在另一个任务之前完成这一限制。
那么运用拓扑排序，我们就能得到满足执行顺序限制条件的一系列任务所需执行的先后顺序。当然也有可能图中并不存在这样一个拓扑顺序，
这种情况下我们无法根据给定要求完成这一系列任务，这种情况称为循环依赖（circular dependency）
    当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。
    https://www.jianshu.com/p/3347f54a3187

二、能解决的问题：
拓扑排序主要用来解决有向图中的依赖解析（dependency resolution）问题。
2.1 有前后依赖/顺序关系的全节点排序(bfs)
2.2 图中最长前后序关联链路长度(bfs)

三部曲：
1. 构造node:[node1, node2,..] , 即邻接表(非邻域矩阵)
2. 计算出indegree
3. topo sort(by bfs)
    3.1 队列依次出队入队，两层循环，每次出队记录，直至队列为空，得到全链路的拓扑排序
    3.2 队列按层次出队入队，三层循环，每个层次的出队时，maxlen += 1，得到最长链路长度

注意坑：
1.在统计indegree时，容易重复计数，导致某个节点的入度变大，导致后续排序结果错误

