Union Find可用于解决集合相关问题，如判断某元素是否属于集合、两个元素是否属同一集合、求解集合个数等
注意，并查集所涉及的动态连通性只是考虑“是否连通”这一二值判别问题，而不涉及连通的路径到底是什么

如果需要的功能不仅仅是检测两个节点是否连通，还需要在连通时得到具体的路径，那么就需要用到别的算法了，比如DFS或者BFS

！！！ 此法适合undirect graph, 不适合direct graph

code pattern:

#find可以通过循环或者递归，递归更加简练
#查找的过程，会整理set内部关系,即将当前i直接挂在root下面，然后返回父节点，也就是根节点

#如果父子只是连接关系，不需要加入路径权值，就直接将返回值赋给parent[i]
    def find(i):
        if i != self.parent[i]:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

#否则，就需要在循环中得到返回值后，对返回值做权值叠加，然后赋给parent[i]
    def find(x):
        p, xr = parent.setdefault(x, (x, 1.0))
        if p != x:
            r, pr = find(p)
            parent[x] = r, pr * xr
        return parent[x]

#union可以直接合并两个set，也可以按照rank来合并
直接合并：
    def union(self, i, j):
        ri = self.find(i)
        rj = self.find(j)
        self.parent[ri] = rj


