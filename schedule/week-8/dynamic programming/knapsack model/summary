从子集和问题到背包问题
https://blog.csdn.net/h843653844/article/details/97619570

一、子集问题：
1、问题定义:
有一个包含n个元素{e1, e2, …, en}的集合S，每个元素ei都有一个对应的权值wi。现在有一个界限W，
我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下达到最大，这个便是子集合问题（事实上还有其他类型的子集和问题)

2、解题思路：
for i = 1, 2, ..., n
    for w = 0, ..., W
        if w < wi
            O[i, w] = O[i-1, w]
        else
            O[i, w] = max(O[i-1, w], wi + O[i-1, w-wi])
    endFor
endFor
算法实际上是实现了一个填表的过程，填了一张n*W的二维表格。整个算法的时间复杂度为O(nW)，显而易见，当W的值变得很大的时候，这个算法的效率堪忧

3、拓展：
现在暂时抛开效率问题，我们发现，上面给出的算法只能算出最优解的值，但是并没有给出所选择的子集合。即农民用这个算法之后只知道他最多能卖多少小番茄，
但还是不知道要卖给哪些收购商。为了解决这个问题，我们只需要反向搜索一下数组O即可在O(n)的时间内找出最优解的元素组合情况。
反向搜索的时候，如果O(i, w)等于O(i-1, w)，说明i没有被选择，继续对前面i-1个元素考虑重量为w时候的情况。
如果O(i, w)不等于O(i-1, w)的话，说明选择了i，然后接着就应该继续对前面i-1个元素考虑重量为(w-wi)时候的情况

二、背包问题：
1.问题定义：
把上面的子集和问题拓展一下，就变成了我们常见的背包问题了。问题定义：有一个包含n个元素{e1, e2, …, en}的集合S，
每个元素ei都有一个对应的权值wi和一个对应的价值vi。现在有一个界限W，我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下，
所有元素的价值总和达到最大。继续拿上面的农民买小番茄的例子来讲，假设现在每个收购商的出价都有所不同，收购商i打算收购wi万斤小番茄，出价vi。
农民只有W万斤能够提供给收购商，他希望合理选择收购商，使得卖小番茄的收益达到最大

2.截图思路：
if w < wi, O(i, w) = O(i-1, w)
else O(i, w) = max(O(i-1, w), vi + O(i-1, w-wi))
